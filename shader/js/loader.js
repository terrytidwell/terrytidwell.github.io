(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.rexpostfxpipelinebehavior = factory());
})(this, (function () { 'use strict';

    function _typeof(obj) {
        "@babel/helpers - typeof";

        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
            return typeof obj;
        } : function (obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _typeof(obj);
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
            writable: false
        });
        return Constructor;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: true,
                configurable: true
            }
        });
        Object.defineProperty(subClass, "prototype", {
            writable: false
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o;
        };
        return _setPrototypeOf(o, p);
    }

    function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
        } catch (e) {
            return false;
        }
    }

    function _assertThisInitialized(self) {
        if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
    }

    function _possibleConstructorReturn(self, call) {
        if (call && (typeof call === "object" || typeof call === "function")) {
            return call;
        } else if (call !== void 0) {
            throw new TypeError("Derived constructors may only return object or undefined");
        }

        return _assertThisInitialized(self);
    }

    function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived),
                result;

            if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;

                result = Reflect.construct(Super, arguments, NewTarget);
            } else {
                result = Super.apply(this, arguments);
            }

            return _possibleConstructorReturn(this, result);
        };
    }

    function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
            object = _getPrototypeOf(object);
            if (object === null) break;
        }

        return object;
    }

    function _get() {
        if (typeof Reflect !== "undefined" && Reflect.get) {
            _get = Reflect.get.bind();
        } else {
            _get = function _get(target, property, receiver) {
                var base = _superPropBase(target, property);

                if (!base) return;
                var desc = Object.getOwnPropertyDescriptor(base, property);

                if (desc.get) {
                    return desc.get.call(arguments.length < 3 ? target : receiver);
                }

                return desc.value;
            };
        }

        return _get.apply(this, arguments);
    }

    var EventEmitterMethods = {
        setEventEmitter: function setEventEmitter(eventEmitter, EventEmitterClass) {
            if (EventEmitterClass === undefined) {
                EventEmitterClass = Phaser.Events.EventEmitter; // Use built-in EventEmitter class by default
            }

            this._privateEE = eventEmitter === true || eventEmitter === undefined;
            this._eventEmitter = this._privateEE ? new EventEmitterClass() : eventEmitter;
            return this;
        },
        destroyEventEmitter: function destroyEventEmitter() {
            if (this._eventEmitter && this._privateEE) {
                this._eventEmitter.shutdown();
            }

            return this;
        },
        getEventEmitter: function getEventEmitter() {
            return this._eventEmitter;
        },
        on: function on() {
            if (this._eventEmitter) {
                this._eventEmitter.on.apply(this._eventEmitter, arguments);
            }

            return this;
        },
        once: function once() {
            if (this._eventEmitter) {
                this._eventEmitter.once.apply(this._eventEmitter, arguments);
            }

            return this;
        },
        off: function off() {
            if (this._eventEmitter) {
                this._eventEmitter.off.apply(this._eventEmitter, arguments);
            }

            return this;
        },
        emit: function emit(event) {
            if (this._eventEmitter && event) {
                this._eventEmitter.emit.apply(this._eventEmitter, arguments);
            }

            return this;
        },
        addListener: function addListener() {
            if (this._eventEmitter) {
                this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
            }

            return this;
        },
        removeListener: function removeListener() {
            if (this._eventEmitter) {
                this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
            }

            return this;
        },
        removeAllListeners: function removeAllListeners() {
            if (this._eventEmitter) {
                this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
            }

            return this;
        },
        listenerCount: function listenerCount() {
            if (this._eventEmitter) {
                return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
            }

            return 0;
        },
        listeners: function listeners() {
            if (this._eventEmitter) {
                return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
            }

            return [];
        },
        eventNames: function eventNames() {
            if (this._eventEmitter) {
                return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
            }

            return [];
        }
    };

    var SceneClass = Phaser.Scene;

    var IsSceneObject = function IsSceneObject(object) {
        return object instanceof SceneClass;
    };

    var GetSceneObject = function GetSceneObject(object) {
        if (object == null || _typeof(object) !== 'object') {
            return null;
        } else if (IsSceneObject(object)) {
            // object = scene
            return object;
        } else if (object.scene && IsSceneObject(object.scene)) {
            // object = game object
            return object.scene;
        } else if (object.parent && object.parent.scene && IsSceneObject(object.parent.scene)) {
            // parent = bob object
            return object.parent.scene;
        }
    };

    var GetValue$1 = Phaser.Utils.Objects.GetValue;

    var ComponentBase = /*#__PURE__*/function () {
        function ComponentBase(parent, config) {
            _classCallCheck(this, ComponentBase);

            this.parent = parent; // gameObject or scene

            this.scene = GetSceneObject(parent);
            this.isShutdown = false; // Event emitter, default is private event emitter

            this.setEventEmitter(GetValue$1(config, 'eventEmitter', true)); // Register callback of parent destroy event, also see `shutdown` method

            if (this.parent && this.parent === this.scene) {
                // parent is a scene
                this.scene.sys.events.once('shutdown', this.onSceneDestroy, this);
            } else if (this.parent && this.parent.once) {
                // bob object does not have event emitter
                this.parent.once('destroy', this.onParentDestroy, this);
            }
        }

        _createClass(ComponentBase, [{
            key: "shutdown",
            value: function shutdown(fromScene) {
                // Already shutdown
                if (this.isShutdown) {
                    return;
                } // parent might not be shutdown yet


                if (this.parent && this.parent === this.scene) {
                    // parent is a scene
                    this.scene.sys.events.off('shutdown', this.onSceneDestroy, this);
                } else if (this.parent && this.parent.once) {
                    // bob object does not have event emitter
                    this.parent.off('destroy', this.onParentDestroy, this);
                }

                this.destroyEventEmitter();
                this.parent = undefined;
                this.scene = undefined;
                this.isShutdown = true;
            }
        }, {
            key: "destroy",
            value: function destroy(fromScene) {
                this.shutdown(fromScene);
            }
        }, {
            key: "onSceneDestroy",
            value: function onSceneDestroy() {
                this.destroy(true);
            }
        }, {
            key: "onParentDestroy",
            value: function onParentDestroy(parent, fromScene) {
                this.destroy(fromScene);
            }
        }]);

        return ComponentBase;
    }();
    Object.assign(ComponentBase.prototype, EventEmitterMethods);

    var PostFXPipeline = Phaser.Renderer.WebGL.Pipelines.PostFXPipeline;
    var GetValue = Phaser.Utils.Objects.GetValue;
    var RemoveIte = Phaser.Utils.Array.Remove;

    var PostFxPipelineBehaviorBase = /*#__PURE__*/function (_ComponentBase) {
        _inherits(PostFxPipelineBehaviorBase, _ComponentBase);

        var _super = _createSuper(PostFxPipelineBehaviorBase);

        function PostFxPipelineBehaviorBase(gameObject, config) {
            var _this;

            _classCallCheck(this, PostFxPipelineBehaviorBase);

            _this = _super.call(this, gameObject, {
                eventEmitter: false
            }); // No event emitter
            // this.parent = gameObject;
            // this.scene
            // Can inject PipelineClass at runtime

            var PipelineClass;

            if (IsPostFxPipelineClass(config)) {
                PipelineClass = config;
                config = undefined;
            } else {
                PipelineClass = GetValue(config, 'PipelineClass');
            }

            if (PipelineClass) {
                _this.createPipeline = function (game) {
                    return new PipelineClass(game);
                };
            }

            var enable = GetValue(config, 'enable', config !== false);

            if (enable) {
                _this.getPipeline(config);
            }

            return _this;
        }

        _createClass(PostFxPipelineBehaviorBase, [{
            key: "shutdown",
            value: function shutdown(fromScene) {
                // Already shutdown
                if (this.isShutdown) {
                    return;
                }

                this.freePipeline();

                _get(_getPrototypeOf(PostFxPipelineBehaviorBase.prototype), "shutdown", this).call(this, fromScene);
            }
        }, {
            key: "getPipeline",
            value: function getPipeline(config) {
                if (!this.pipeline) {
                    var pipeline = this.createPipeline(this.scene.game);
                    var gameObject = this.parent;
                    var postPipelines = gameObject.postPipelines;
                    pipeline.gameObject = gameObject;
                    postPipelines.push(pipeline);
                    gameObject.hasPostPipeline = postPipelines.length > 0;
                    this.pipeline = pipeline;
                }

                if (config && this.pipeline.resetFromJSON) {
                    this.pipeline.resetFromJSON(config);
                }

                return this.pipeline;
            }
        }, {
            key: "freePipeline",
            value: function freePipeline() {
                if (!this.pipeline) {
                    return this;
                }

                var gameObject = this.parent;
                var postPipelines = gameObject.postPipelines;
                RemoveIte(postPipelines, this.pipeline);
                gameObject.hasPostPipeline = postPipelines.length > 0;
                this.pipeline.destroy();
                this.pipeline = undefined;
                return this;
            } // Override

        }, {
            key: "createPipeline",
            value: function createPipeline(game) {}
        }]);

        return PostFxPipelineBehaviorBase;
    }(ComponentBase);

    var IsPostFxPipelineClass = function IsPostFxPipelineClass(object) {
        return object && object.prototype && object.prototype instanceof PostFXPipeline;
    };

    return PostFxPipelineBehaviorBase;

}));